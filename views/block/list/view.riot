<block-list-view>
  <div class={ `flex-1 d-flex flex-column h-100 w-100${props.block.background ? '' : ' card'}` }>
    <div if={ props.block.name } class={ props.block.background ? ' mb-2' : 'card-header' }>
      <b>{ props.block.name }</b>
    </div>
    <div if={ loading('list') } class={ `text-center${props.block.background ? '' : ' card-body'}` }>
      <i class="fa fa-spinner fa-spin" />
    </div>
    <div class={ `oy-scroll flex-column flex-1${props.block.background ? '' : ' card-body'}` }>
      <block-contacts-item if={ !loading('list') } each={ (item, i) in state.list } item={ item } { ...getProps() } />
    </div>
  </div>

  <script>
    // import scrollbar
    import PerfectScrollbar from 'perfect-scrollbar';

    // import task
    import blockContactsItem from './item.riot';

    // export default
    export default class BlockListView {

      /**
       * local components
       */
      static get components() {
        // return components
        return {
          blockContactsItem,
        };
      }

      /**
       * on before mount
       */
      onBeforeMount(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // set state
        this.state.skip  = 0;
        this.state.limit = 25;

        // bind methods
        this.getQuery = this.getQuery.bind(this);
        this.loadList = this.loadList.bind(this);

        // safe update
        this.safeUpdate = () => {
          this.update();
        };

        // add listeners
        this.props.page.on('do.sort', this.loadList);
        this.props.page.on('do.filter', this.loadList);
        this.props.page.on('data.model', this.loadList);
        this.props.page.on('data.filter', this.loadList);
      }

      /**
       * on before mount
       */
      onBeforeUnmount(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // check listening
        if (this.state.list && this.state.list.removeListener) {
          // remove current listener and deafen
          this.state.list.removeListener('update', this.safeUpdate);
          this.state.list.deafen();
        }

        // add listeners
        this.props.page.removeListener('do.sort', this.loadList);
        this.props.page.removeListener('do.filter', this.loadList);
        this.props.page.removeListener('data.model', this.loadList);
        this.props.page.removeListener('data.filter', this.loadList);
      }

      /**
       * on mounted
       */
      onMounted() {
        // check frontend
        if (typeof window === 'undefined') return;
        
        // fix column sizing
        if (this.$('.oy-scroll') && !this.$('.oy-scroll.ps')) {
          // ps
          this.ps = new PerfectScrollbar(this.$('.oy-scroll'), {
            suppressScrollX : true,
          });
        }

        // load list
        this.loadList();
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // GET METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * load list
       */
      async loadList() {
        // check model
        if (!this.getSelectedModel()) return;

        // get query
        const query = this.getQuery();

        // loading
        this.loading('list', true);

        // check listening
        if (this.state.list && this.state.list.removeListener) {
          // remove current listener and deafen
          this.state.list.removeListener('update', this.safeUpdate);
          this.state.list.deafen();
        }

        // list
        const list = await query.skip(this.state.skip).limit(this.state.limit).listen();

        // safe update
        list.on('update', this.safeUpdate);
        
        // update state
        this.update({
          list,
          count : await this.getQuery().count(),
        });

        // loading
        this.loading('list', false);
      }

      /**
       * get selected model
       */
      getSelectedModel() {
        // check model
        return this.props.block.model || this.props.model;
      }

      /**
       * get selected forms
       */
      getSelectedForms() {
        // forms
        let forms = this.props.block.forms || [];

        // check form
        if (!forms.length && this.props.form) forms = [this.props.form];
        if (!forms.length && this.props.forms) forms = this.props.forms;

        // return forms
        return forms;
      }

      /**
       * get props
       */
      getProps() {
        // clone
        const newProps = { ...(this.props) };

        // delete
        delete newProps.type;
        delete newProps.view;
        delete newProps.item;
        delete newProps.class;
        delete newProps.struct;
        delete newProps.fields;

        // return
        return newProps;
      }

      /**
       * get fields
       */
      getFields() {
        // get forms
        const forms = this.getSelectedForms();

        // return fields
        return Array.from(this.props.dashup.get('pages').values()).filter((page) => {
          // return model pages
          return page.get('type') === 'form' && forms.includes(page.get('_id'));
        }).reduce((accum, page) => {
          // fields
          accum.push(...(page.get('data.fields') || []));
          
          // return accum
          return accum;
        }, []);
      }

      /**
       * get query
       */
      getQuery() {
        // set query
        let query = this.props.dashup.page(this.getSelectedModel());

        // forms
        const forms = this.getSelectedForms();
        const fields = this.getFields();

        // check items
        if (forms.length) {
          // loop forms
          query = query.in('_meta.form', forms);
        }

        // load filter
        let filter = [];

        // check page filter
        if (this.props.page.get('data.model') === this.getSelectedModel()) {
          // try/catch
          try {
            filter.push(...(JSON.parse(this.props.page.get('data.filter'))));
          } catch (e) {}
        }
        
        // try/catch
        try {
          filter.push(...(JSON.parse(this.props.block.filter)));
        } catch (e) {}

        // add initial where
        if (filter) {
          // add wheres
          filter.forEach((where) => {
            // where
            query = query.where(where);
          });
        }

        // search
        if (this.props.search && this.props.search.length) {
          // add search
          query = query.search(this.props.search);
        }

        // test by user
        if ((this.props.page.get('user.filter') || {}).me) {
          // get user fields
          const userFields = [...(fields || [])].filter((f) => (this.props.page.get('data.user') || []).includes(f.uuid));
          
          // loop fields
          query = query[userFields.length > 1 ? 'or' : 'where'](...(userFields.map((userField) => {
            // return or
            return {
              [userField.name || userField.uuid] : this.props.dashup.get('_meta.member'),
            };
          })));
        }

        // user query
        (this.props.page.get('user.where') || []).forEach((where) => {
          // types
          const numberTypes = ['gt', 'lt', 'gte', 'lte'];

          // add query
          query = query[where[0]](where[1], numberTypes.includes(where[0]) ? parseFloat(where[2]) : where[2]);
        });

        // check vals
        const tagFields = [...(fields || [])].filter((f) => (this.props.page.get('data.tag') || []).includes(f.uuid));

        // get tags
        const userTags = (this.props.page.get('user.filter.tags') || []).filter((id) => {
          // return find
          return tagFields.find((t) => {
            // check id
            return (t.options || []).find((o) => o.value === id);
          });
        });

        // get filter tags
        if (userTags.length) {
          // loop fields
          query = query[tagFields.length > 1 ? 'or' : 'where'](...(tagFields.map((tagField) => {
            // return or
            return {
              [tagField.name || tagField.uuid] : userTags,
            };
          })));
        }

        // check sort
        if (this.props.page.get('data.sort.id')) {
          // get field
          const sortField = this.props.page.get('data.sort.sort') ? {
            name : this.props.page.get('data.sort.sort'),
          } : fields.find((f) => f.uuid === this.props.page.get('data.sort.id'));

          // sort by that
          if (sortField) query = query.sort(sortField.name || sortField.uuid, this.props.page.get('data.sort.way'));
        }
 
        // return query
        return query;
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // MISC METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * ref
       */
      ref(name) {
        // set refs
        if (!this.refs) this.refs = {};

        // return ref function
        return (that) => {
          // set ref
          this.refs[name] = that;
        };
      }

      /**
       * set loading
       */
      loading(type, way) {
        // set loading
        if (!this.__loading) this.__loading = new Map();

        // check loading
        if (!type) return !!Array.from(this.__loading.values()).find((v) => v);
        if (typeof way === 'undefined') return !!this.__loading.get(type);

        // set loading
        this.__loading.set(type, way);
        this.update();
      }
    }
  </script>
</block-list-view>