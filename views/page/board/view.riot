<page-board-view>
  <div class="d-flex flex-column flex-1">
    <a href="#!" class="d-block alert alert-info mb-3" if={ !props.page.get('data.model') } onclick={ (e) => props.onConfig(e) }>
      <i class="fa fa-exclamation-triangle mr-2" />
      Please select a <b>model</b> for the board.
    </a>
    <a href="#!" class="d-block alert alert-info mb-3" if={ !props.page.get('data.forms.0') } onclick={ (e) => props.onConfig(e) }>
      <i class="fa fa-exclamation-triangle mr-2" />
      Please select a <b>form</b> for the board.
    </a>
    <a href="#!" class="d-block alert alert-info mb-3" if={ !props.page.get('data.group') } onclick={ (e) => props.onConfig(e) }>
      <i class="fa fa-exclamation-triangle mr-2" />
      Please select a <b>grouping field</b> for the board.
    </a>

    <!-- LOADING -->
    <div if={ !state.columns } class="text-center my-5 py-5">
      <i class="fa fa-spin fa-spinner h1" />
    </div>
    <!-- / LOADING -->

    <!-- BOARD -->
    <div class="view-columns flex-1" if={ props.page.get('data.group') && state.columns }>
      <!-- BACKLOG -->
      <div data-column="backlog" if={ !props.page.get('data.backlog.disabled') }>
        <div class="column-header">
          { props.page.get('data.backlog.name') || 'Backlog' }
        </div>
        <div class="column-body">
          <div class="column-body-inner">
            <div class="card">
              <div class="card-body task-container" data-id="backlog" if={ !loading('backlog') }>
                <div each={ (item, i) in getItems({ value : 'backlog' }) } is="page-board-task" data-id={ item.get('_id') } if={ !item.get(`${state.columns.name || state.columns.uuid}.0`) || item.get(`${state.columns.name || state.columns.uuid}.0`) === 'backlog' } class={ `${isVisible(item) ? '' : 'd-none'}` } item={ item } form-fields={ state.fields } on-item={ (e) => props.onItem(e, item) } add-user={ onAddUser } add-tag={ onAddTag } { ...getProps() } />
              </div>
              <div class="card-body task-container text-center" data-id="backlog" if={ loading('backlog') }>
                <i class="fa fa-spinner fa-spin" />
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- / BACKLOG -->

      <!-- COLUMNS -->
      <div each={ (column, i) in state.columns.options } data-column={ column.value }>
        <div class="column-header">
          <i if={ !column.label }>N/A</i>
          { column.label }
        </div>
        <div class="column-body">
          <div class="column-body-inner">
            <div class="card">
              <div class="card-body task-container" data-id={ column.value } if={ !loading(column.value) }>
                <div each={ (item, i) in getItems(column) } is="page-board-task" data-id={ item.get('_id') } if={ item.get(`${state.columns.name || state.columns.uuid}.0`) === column.value } class={ `${isVisible(item) ? '' : 'd-none'}` } item={ item } form-fields={ state.fields } on-item={ (e) => props.onItem(e, item) } add-user={ onAddUser } add-tag={ onAddTag } { ...getProps() } />
              </div>
              <div class="card-body task-container text-center" data-id={ column.value } if={ loading(column.value) }>
                <i class="fa fa-spinner fa-spin" />
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- / COLUMNS -->
    </div>
    <!-- / BOARD -->

    <!-- TAGS -->
    <div class="dropdown-menu show m-0 p-0" if={ state.model && state.menu === 'tag' } aria-labelledby={ `tag-${state.model.get('_id')}` } id={ `tag-dd-${state.model.get('_id')}` }>
      <dashup-tag ref={ ref('model') } { ...props } />
    </div>
    <div class="dropdown-menu show m-0 p-0" if={ state.model && state.menu === 'user' } aria-labelledby={ `user-${state.model.get('_id')}` } id={ `user-dd-${state.model.get('_id')}` }>
      <dashup-user ref={ ref('model') } { ...props } />
    </div>
    <!-- / TAGS -->
  </div>

  <script>
    // require base class
    import uuid from 'uuid';
    import dotProp from 'dot-prop';
    import PerfectScrollbar from 'perfect-scrollbar';

    // import modules
    import pageBoardTask from './task';

    // export default
    export default class PageBoardView {


      // ////////////////////////////////////////////////////////////////////////////
      //
      // RIOT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * local components
       */
      static get components() {
        // return components
        return {
          pageBoardTask,
        };
      }

      /**
       * on before mount
       */
      onBeforeMount(...args) {
        // bind
        this.onAddTag  = this.onAddTag.bind(this);
        this.onAddUser = this.onAddUser.bind(this);

        // bind
        this.init     = this.init.bind(this);
        this.initSort = this.initSort.bind(this);

        // module
        this.scrolls = new Map();

        // set force update
        this.scheduleUpdate = () => {
          // update
          this.update();
        };
      }

      /**
       * on mounted
       *
       * @param {Array} args
       */
      onMounted(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // init
        this.init();

        // where
        this.props.page.on('data.model', this.init);
        this.props.page.on('data.field', this.init);
        this.props.page.on('data.backlog', this.scheduleUpdate);
        this.props.page.on('do.user.where', this.init);
        this.props.page.on('do.data.filter', this.init);
      }

      /**
       * on mounted
       *
       * @param {Array} args
       */
      onBeforeUnmount(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // sortables
        if (this.sortables) {
          try {
            // destroy
            this.sortables.forEach((sortable) => sortable.destroy());
          } catch (e) {}

          // reset
          this.sortables = [];
        }

        // items
        if (this.state.items && this.state.items.removeListener) {
          // safe update
          this.state.items.removeListener('update', this.scheduleUpdate);
        }

        // where
        this.props.page.removeListener('data.model', this.init);
        this.props.page.removeListener('data.field', this.init);
        this.props.page.removeListener('data.backlog', this.scheduleUpdate);
        this.props.page.removeListener('do.user.where', this.init);
        this.props.page.removeListener('do.data.filter', this.init);
      }

      /**
       * on updated
       */
      onUpdated(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // set ps
        if (!this.$('.ps') && this.$('.view-columns')) {
          // perfect scrollbar
          this.ps = new PerfectScrollbar(this.$('.view-columns'));
        }

        // add perfect scrollbar
        Array.from(this.$$('.task-container')).forEach((item) => {
          // check item
          if ($('.ps__rail-y', item).length || $(item).hasClass('ps')) return;

          // set item
          if (this.scrolls.get(item.getAttribute('data-id'))) {
            // set scroll
            item.scrollTop = this.scrolls.get(item.getAttribute('data-id'));
          }

          // perfect scrollbar
          new PerfectScrollbar(item);

          // log
          item.addEventListener('ps-scroll-y', (e) => {
            // set item
            this.scrolls.set(item.getAttribute('data-id'), e.target.scrollTop);
          });
        });

        // view columns
        if (this.$('.view-columns')) {
          // init sort
          this.initSort();
        }
      }

      /**
       * should update
       */
      shouldUpdate() {
        // check updating
        return !this.__canUpdate;
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // EVENT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * on submit
       *
       * @param {Event} e
       */
      onAddTag(e, model) {
        // close popped
        if (this.closePopped) this.closePopped();

        // submit form
        this.update({
          menu : 'tag',
          model,
        });

        // create popped
        this.popped = new Popper(this.$(`#tag-${model.get('_id')}`), this.$(`#tag-dd-${model.get('_id')}`), {
          placement : 'left-start'
        });

        // container
        const container = $(this.$(`#tag-dd-${model.get('_id')}`));

        // create close popped
        const closePopped = (e) => {
          // reset
          this.closePopped = null;

          // check
          if (!container.is(e.target) && container.has(e.target).length === 0) {
            // close
            this.popped = null;
            this.update({
              menu  : null,
              model : null,
            });

            // remove listener
            $(document).off('mouseup', closePopped);
          }
        };
        this.closePopped = closePopped;

        // add listener
        $(document).on('mouseup', closePopped);
      }

      /**
       * on submit
       *
       * @param {Event} e
       */
      onAddUser(e, model) {
        // close popped
        if (this.closePopped) this.closePopped();

        // submit form
        this.update({
          menu : 'user',
          model,
        });

        // create popped
        this.popped = new Popper(this.$(`#user-${model.get('_id')}`), this.$(`#user-dd-${model.get('_id')}`), {
          placement : 'left-start'
        });

        // container
        const container = $(this.$(`#user-dd-${model.get('_id')}`));

        // create close popped
        const closePopped = (e) => {
          // reset
          this.closePopped = null;

          // check
          if (!container.is(e.target) && container.has(e.target).length === 0) {
            // close
            this.popped = null;
            this.update({
              menu  : null,
              model : null,
            });

            // remove listener
            $(document).off('mouseup', closePopped);
          }
        };
        this.closePopped = closePopped;

        // add listener
        $(document).on('mouseup', closePopped);
      }

      /**
       * get props
       */
      getProps() {
        // clone
        const newProps = { ...(this.props) };

        // delete
        delete newProps.ref;
        delete newProps.type;
        delete newProps.view;
        delete newProps.class;
        delete newProps.struct;
        delete newProps.onItem;

        // return
        return newProps;
      }

      /**
       * get items
       *
       * @param {String} col
       */
      getItems(col) {
        // check frontend
        if (typeof window === 'undefined') return [];
        if (!this.state.columns) return [];

        // return queries
        return (this.state.items || []).filter((row) => {
          // value
          const value = row.get(`${this.state.columns.name || this.state.columns.uuid}.0`);

          // check col
          if (value === col.value) return true;
          if ((!value || value === 'backlog') && col.value === 'backlog') return true;
        }).sort((a, b) => {
          // sort order
          const aC = a.get(`_meta.${this.props.page.get('_id')}.order`) || 0;
          const bC = b.get(`_meta.${this.props.page.get('_id')}.order`) || 0;

          // check order
          if (bC > aC) return -1;
          if (bC < aC) return 1;
          return 0;
        });
      }

      /**
       * get fields
       */
      getFields() {
        // reduce
        return (this.props.page.get('data.forms') || []).reduce((accum, form) => {
          // check form
          if (!form) return accum;

          // get form
          const actualForm = this.props.dashup.page(form);

          // check fields
          if (!actualForm || !actualForm.get('data.fields')) return [];

          // return data
          accum.push(...(actualForm.get('data.fields').map((field) => {
            // clone field
            const newField = { ...field };

            // set form
            newField.form = form;

            // new field
            return newField;
          })));

          // return accum
          return accum;
        }, []);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // Init Methods
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * init
       */
      async init() {
        // sortables
        if (this.sortables) {
          try {
            // destroy
            this.sortables.forEach((sortable) => sortable.destroy());
          } catch (e) {}

          // reset
          this.sortables = [];
        }

        // items
        if (this.state.items && this.state.items.removeListener) {
          // safe update
          this.state.items.removeListener('update', this.scheduleUpdate);
        }

        // get column field
        const fields = this.getFields();
        const columns = fields.find((f) => f.uuid === this.props.page.get('data.group'));

        // get model
        let items = [];
        const model = this.props.page.get('data.model');

        // query by
        if (model) {
          // set query
          let query = this.props.dashup.page(model);

          // check items
          if ((this.props.page.get('data.forms') || []).length) {
            // loop forms
            query = query.in('_meta.form', this.props.page.get('data.forms'));
          }

          // load filter
          let filter = null;

          // try/catch
          try {
            filter = JSON.parse(this.props.page.get('data.filter'));
          } catch (e) {}

          // add initial where
          if (filter) {
            // add wheres
            filter.forEach((where) => {
              // where
              query = query.where(where);
            });
          }

          // check where
          (this.props.page.get('user.where') || []).forEach((where) => {
            // add query
            query = query[where[0]](where[1], where[2]);
          });

          // listen
          items = await query.listen();
        }

        // update
        this.update({
          items,
          fields,
          columns,
        });

        // safe update
        if (items && items.on) items.on('update', this.scheduleUpdate);

        // set values
        if (this.$('.view-columns')) this.ps = this.ps || new PerfectScrollbar(this.$('.view-columns'));

        // init sort
        this.initSort();

        // add perfect scrollbar
        Array.from(this.$$('.task-container')).forEach((item) => {
          // perfect scrollbar
          const ps = new PerfectScrollbar(item);

          // log
          item.addEventListener('ps-scroll-y', (e) => {
            // set item
            this.scrolls.set(item.getAttribute('data-id'), e.target.scrollTop);
          });
        });
      }

      /**
       * init sort
       */
      initSort () {
        // require sort
        const Sortable = require('sortablejs');

        // sortables
        if (this.sortables) {
          try {
            // destroy
            this.sortables.forEach((sortable) => sortable.destroy());
          } catch (e) {}
        }

        // sortables
        this.sortables = [];

        // check can
        if (!this.props.dashup.can(this.props.page, 'submit')) return;

        // check init
        if (!this.$$('.task-container').length) return;

        // create sortables
        this.$$('.task-container').forEach((item) => {
          // push
          this.sortables.push(new Sortable(item, {
            group          : 'task-container',
            draggable      : '[is="page-board-task"]',
            animation      : 200,
            fallbackOnBody : true,

            onEnd : async (e) => {
              // set item
              const el     = e.item;
              const target = e.to;
              const source = e.from;

              // set column
              const col    = $(target).attr('data-id') || null;
              const column = this.state.columns.options.find(c => c.value === col);
              
              // updates
              const updates = [];

              // set updating
              this.__canUpdate = true;

              // list all in target
              $('.card-task', target).each((i, item) => {
                // make sure not 0
                i = i + 1;

                // get item
                const task = (this.state.items || []).find((t) => {
                  // return accumulator
                  return t.get('_id') === $(item).attr('data-id');
                });

                // check column fields
                if ((task.get(`${this.state.columns.name || this.state.columns.uuid}.0`) || 'backlog') !== (col || 'backlog')) {
                  // push update
                  updates.push(task);
                  task.set(`${this.state.columns.name || this.state.columns.uuid}`, [(col || 'backlog')]);
                }

                // check order
                if (task.get(`_meta.${this.props.page.get('_id')}.order`) !== i) {
                  // set order
                  updates.push(task);
                  task.set(`_meta.${this.props.page.get('_id')}.order`, i);
                }
              });

              // check updates
              await Promise.all(updates.map((update) => update.save()));

              // set updating
              this.__canUpdate = false;

              // load columns
              [col, $(source).attr('data-id')].forEach((col) => {
                this.loading(col || 'backlog', true);
                this.loading(col || 'backlog', false);
              });
            }
          }));
        });

        // create sortables
        this.$$('.view-columns').forEach((item) => {
          // push
          this.sortables.push(new Sortable(item, {
            group            : 'view-columns',
            delay            : 2 * 1000,
            handle           : '.btn-moves',
            animation        : 200,
            fallbackOnBody   : true,
            delayOnTouchOnly : true,

            onEnd : async (e) => {
              // set item
              const el     = e.item;
              const target = e.to;
              const source = e.from;

              // reorder columns
              const alters = this.props.page.get('data.alters') || [];

              // check columns
              $('.card', target).each((i, item) => {
                // get found
                let found = alters.find((col) => col.id === $(item).attr('data-column'));
                const column = this.state.find((col) => col.id === $(item).attr('data-column'));

                // check found
                if (!found) {
                  // set found
                  found = {
                    id    : $(item).attr('data-column'),
                    order : i,
                  };

                  // push alters
                  alters.push(found);
                } else {
                  // set found
                  found.order = i;
                }

                // set in column
                column.set('order', i);
              });

              // update
              this.loading('columns', true);

              // onset
              this.props.data('alters', alters);

              // update
              this.loading('columns', false);
            }
          }));
        });
      }

      /**
       * is filter me
       */
      isFilter(type, val) {
        // check me
        return ((this.props.page.get('user.filter') || {})[type] || false) === val;
      }

      /**
       * check visible
       */
      isVisible(task) {
        // tags
        const tags = this.props.search && this.props.search.length ? this.props.search.toLowerCase().split(' ') : [];

        // check filter
        if (this.isFilter('me', true)) {
          // check vals
          let vals = (task.get(this.props.page.get('data.user.name') || this.props.page.get('data.user.uuid')) || []);

          // vals
          if (vals && !Array.isArray(vals)) vals = [vals];

          // only me
          if (!vals.find((val) => {
            // user
            return val.user === eden.user.get('id');
          })) return false;
        }

        // check tags
        if ((this.props.page.get('user.filter.tags') || []).length) {
          // check filter
          if (this.props.page.get('user.filter.tags').find((tag) => {
            // check tag exists on task
            let val = task.get(this.props.page.get('data.tag.name') || this.props.page.get('data.tag.uuid')) || [];

            // set value
            if (typeof val === 'string') val = [val];

            // check tag
            return !val.includes(tag);
          })) return false;
        }

        // filter
        if (tags.length) {
          // search item
          const searchable = JSON.stringify(task.get()).toLowerCase();

          // search JSON
          if (tags.find((tag) => {
            // check
            return !searchable.includes(tag);
          })) return false;
        }

        // return true
        return true;
      }

      /**
       * ref
       */
      ref(name) {
        // set refs
        if (!this.refs) this.refs = {};

        // return ref function
        return (that) => {
          // set ref
          this.refs[name] = that;
        };
      }

      /**
       * set loading
       */
      loading(type, way) {
        // set loading
        if (!this.__loading) this.__loading = new Map();

        // check loading
        if (!type) return !!Array.from(this.__loading.values()).find((v) => v);
        if (typeof way === 'undefined') return !!this.__loading.get(type);

        // set loading
        this.__loading.set(type, way);
        this.update();
      }
    }
  </script>
</page-board-view>